v1
v1
v1
v1 <- c(1, 2, 3, 4, 5)             # 숫자형 벡터
v2 <- c("a", "b", "C")             # 문자형 벡터
v3 <- c(1, 2, 3, "a", "b", "c")    # 문자형 벡터
print(v1)
print(v2)
print(v3)
v1 <- c(1, 2, 3, 4, 5)             # 숫자형 벡터
v2 <- c("a", "b", "C")             # 문자형 벡터
v3 <- c(1, 2, 3, "a", "b", "c")    # 문자형 벡터
print(v1)
print(v2)
print(v3)
v1 <- c(1, 2, 3, 4, 5)             # 숫자형 벡터
v2 <- c("a", "b", "C")             # 문자형 벡터
v3 <- c(TRUE, FALSE, FALSE)        # 논리형 벡터
v4 <- c(1, 2, 3, "a", "b", "c")    # 문자형 벡터
print(v1) # [1] 1 2 3 4 5
print(v2) # [1] "a" "b" "C"
print(v3) #
print(v4) # [1] "1" "2" "3" "a" "b" "c"
v6
# 벡터 결합 가능
v5 <- c(6, 7, 8, 9, 10)
v6 <- c(v1, v5)
print(v6)
v7 <- 1:10
print(v7)
# 연속적인 데이터 생성시 콜론 이용
v7 <- 1:15
# 연속적인 데이터 생성시 콜론 이용
v7 <- 1:15
print(v7)
v8 <- seq(1, 10, 2)
print(v8)
v8 <- seq(1, 10, 2)
v9 <- seq("a", "b", 2)
v9 <- rep(1:5, times=3)
v10 <- rep(1:5, each=3)
print(v9)
print(v10)
v <- c(6, 8, 1, 9, 7)
print(v[1])
print(v[6])
print(v[c(1, 3, 5)])    #
print(v[1:3])
print(v[seq(2, 5, 2)])
print(v[rep(1, 10)])
print(-5)
print(v[-5])
print(v[-c(2, 4)])
print(v[rep(c(1, 3, 4), each=10)])
print(length(v))
print(v11 + 2)   #
## 벡터의 산술연산
v11 <-c(3, 7, 6)
print(v11 + 2)   #
## 벡터의 산술연산
# 벡터에 대한 산술연산은 벡터의 모든 값들에 대한 연산으로 바뀌어 실행
# 벡터와 벡터 간 연산은 대응되는 위치에 있는 값끼리의 연산으로 바뀌어 실행됨
v11 <- c(3, 7, 6)
v12 <- c(4, 2, 8)
print(v11 + 2)   # [1] 5 9 8
print(v11 - v12) #
## 벡터의 산술연산
# 벡터에 대한 산술연산은 벡터의 모든 값들에 대한 연산으로 바뀌어 실행
# 벡터와 벡터 간 연산은 대응되는 위치에 있는 값끼리의 연산으로 바뀌어 실행됨
# 벡터 간 연산 중 벡터의 길이가 서로 다른 경우 짧은 벡터를 처음부터 반복시킴
v11 <- c(3, 7, 6)
v12 <- c(4, 2, 8)
v13 <- 1:5
print(v11 + 2)   # [1] 5 9 8
print(v11 - v12) # [1] -1  5 -2
print(v11 + v13)
## 벡터에 적용 가능한 함수
# sum : 합계
print(sum(1:100))
# mean : 평균
print(mean(1:100))
# median : 전체 값의 중간값
print(median(1:100))
# max : 최댓값
print(max(1:100))
# min : 최솟값
print(min(1:100))
# var : 분산(variance)
print(var(1:100))
# sd : 표준편차(standard deviation) 분산에 루트를 씌운 것 == sqrt(var())
print(sd(1:100))
print(sqrt(var(1:100)))
# length : 벡터에 포함된 값들의 개수
print(length(1:100))
## 2.2.5 논리연산자
# 등호와 부등호는 (>, <, >=, <=, ==, !=)로 동일함
# 논리연산도 벡터에 포함된 각각의 값에 대한 연산으로 바뀌어 실행됨
v14 <- 1:10
# 각 원소가 5보다 크거나 같으면 TRUE, 아니면 FALSE 출력
print(v14 >= 5)
# 인덱스 안에 논리연산자가 포함되면 TRUE에 해당하는 값들만 반환함
print(v14[v14 >= 5])
# 논리값이 산술연산에 사용되면 TRUE는 1로, FALSE는 0으로 간주됨
# TRUE의 개수를 합한 값이 출력. 결과적으로 조건을 만족하는 값의 개수를 출력.
print(sum(v14 >= 5))
# v14에서 5보다 크거나 같은 값들의 합계 출력
print(sum(v14[v14 >= 5])) #
table(v14 >= 5)
myinfo
## 2.2.6 리스트
# 서로 다른 자료형의 값들을 1차원 배열에 저장하고 다룰 수 있도록 함
# list() 함수를 이용하여 리스트 생성
# 리스트에 저장된 값은 [[]]를 사용하거나, 리스트이름$값의이름 의 형태로 추출 가능
myinfo <-list(name="kim", age=25, smoking="FALSE", score=c(90,95,100))
myinfo
## 2.2.6 리스트
# 서로 다른 자료형의 값들을 1차원 배열에 저장하고 다룰 수 있도록 함
# list() 함수를 이용하여 리스트 생성
# 리스트에 저장된 값은 [[]]를 사용하거나, 리스트이름$값의이름 의 형태로 추출 가능
myinfo <-list(name="kim", age=25, smoking="FALSE", score=c(90,95,100))
print(myinfo[[1]])
print(myinfo$score)
## 2.2.7 팩터(factor)
# 문자형 데이터가 저장된 벡터의 한 종류
# 문자형 벡터를 만든 뒤 factor() 함수를 이용하여 팩터를 생성
fav_season <- c("spring", "fall", "winter", "summer", "summer", "spring")
table(fav_season)
factor_fav_season = factor(fav_season)
print(fav_season)
print(factor_fav_season)
print(levels(factor_fav_season))
## 2.2.7 팩터(factor)
# 문자형 데이터가 저장된 벡터의 한 종류
# 문자형 벡터를 만든 뒤 factor() 함수를 이용하여 팩터를 생성
# levels() 함수는 팩터에 저장된 값들의 종류를 알려줌
# 팩터는 사전에 정의된 값 외에 다른 값들은 입력하지 못하도록 함
fav_season <- c("spring", "fall", "winter", "summer", "summer", "spring")
table(fav_season)
fac_fav_season = factor(fav_season)
print(fav_season)
print(fac_fav_season)
print(levels(fac_fav_season))
table(fac_fav_season)
# 벡터를 이용해 팩터를 생성할 때 파라미터로 levels를 지정하면 순서를 지정할 수 있음
fac2_fav_season <- factor(fav_season, levels=c("spring", "summer", "fall", "winter"))
table(fac2_fav_season)
# levels() 함수는 팩터에 저장된 값들의 종류를 알려줌
print(levels(fac_fav_season))
barplot(fac_fav_season)
barplot(table(fac_fav_season))
# levels() 함수는 팩터에 저장된 값들의 종류를 알려줌
print(levels(fac2_fav_season))
barplot(table(fac2_fav_season)) # barplot() 함수를 이용해 막대 그래프로 시각적으로 표현 가능
# levels() 함수는 팩터에 저장된 값들의 종류를 알려줌
print(levels(fac2_fav_season))
# 팩터는 사전에 정의된 값 외에 다른 값들은 입력하지 못하도록 함
fac2_fav_season[7] = "summer"
print(fac2_fav_season)
fac2_fav_season[8] = "abc"
print(fac2_fav_season)
## 2.3.1 행렬 이해
# 2차원 테이블 형태의 자료구조
# 모든 셀에 저장되는 값은 동일한 자료형이어야 함
# matrix() 함수를 이용하여 행렬 생성
# 매개변수 nrow, ncol : 행렬의 행과 열의 개수 지정
# 매개변수 byrow : TRUE인 경우 행렬에 저장될 값들을 행 방향으로 채움. 기본값은 FALSE
m1 <- matrix(1:20, nrow=4, ncol=5)
print(m1)
## 2.3.1 행렬 이해
# 2차원 테이블 형태의 자료구조
# 모든 셀에 저장되는 값은 동일한 자료형이어야 함
# matrix() 함수를 이용하여 행렬 생성
# 매개변수 nrow, ncol : 행렬의 행과 열의 개수 지정
# 매개변수 byrow : TRUE인 경우 행렬에 저장될 값들을 행 방향으로 채움. 기본값은 FALSE
m1 <- matrix(1:20, nrow=4, ncol=5, byrow=TRUE)
print(m1)
m2 <- matrix(1:20, nrow=4, ncol=5, byrow=TRUE)
print(m1)
print(m2)
m1 <- matrix(1:20, nrow=4, ncol=5)  # 1:20와 nrow만 인자로 넘겨도 매트릭스는 생성됨. 1:20과 ncol만 넘겨도 마찬가지
m2 <- matrix(1:20, nrow=4, ncol=5, byrow=TRUE)
print(m1)
print(m2)
# 2개의 인덱스 값으로 행렬의 원소 추출 가능
# [행, 열]과 같이 사용
# 행 또는 열을 지정하지 않는 경우 입력한 열 또는 행 전체를 추출
print(m1[2, 4]) # 2행 4열의 값 출력
print(m1[3, ])  # 3행 전체 출력
print(m1[, 5])  # 5열 전체 출력
print(m1[,])    # 모든 행, 열을 출력(매트릭스 전체 출력)
# rbind(), cbind() 함수를 이용해 벡터 또는 행렬 결합 가능
# rbind() : row 방향으로 붙임 (아래에 결합)
# cbind() : column 방향으로 붙임 (오른쪽에 결합)
m3 <- rbind(m1, m2)
print(m3)
m4
m4 <- cbind(m1, m2)
print(m4)
m5 <- cbind(m1, 1:6)
m5 <- cbind(m1, 1:5)
m5 <- cbind(m1, 1:4)
print(m5)
m5 <- cbind(m1, c(1:4))
print(m5)
score <- matrix(c(80, 67, 74,
82, 95, 88,
75, 84, 82),
nrow = 3, ncol = 3, byrow = TRUE)
rownames(score) <- c("Kim", "Lee", "Park")
colnames(score) <- c("Kor", "Eng", "Math")
print(score)
m5 <- cbind(m1, c(1:8))
m5 <- cbind(m1, c(1:2))
print(m5)
m5 <- cbind(m1, c(1:4))
print(m5)
print(rownames(score))
print(colnames(score))
df1 <- data.frame(name = c("Kim", "Lee", "Park", "Choi"),
age = c(24, 25, 22, 27),
btype = factor(c("A", "B", "O", "B")),
religion = c(TRUE, FALSE, TRUE, TRUE))
print(df1)
# 매트릭스와 동일한 방법으로 데이터 추출 가능
print(df1[1, 2])   # 1행 2열에 위치한 값 출력
print(df1[, 3])    # 3열의 모든 값 출력
# 데이터프레임에서는 열의 이름을 통해 열 데이터를 추출할 수 있음
# `(데이터프레임 이름)$(열 이름)`
print(df1$btype)
# cbind()와 rbind()를 이용해 벡터 또는 데이터프레임과 결합 가능
df2 <- cbind(df1, c("dog", "cat", "bird", "dog"))
print(df2)
colnames(df2)[5] <- "pet"
print(df2)
print(colnames(df2))
# cbind()와 rbind()를 이용해 벡터 또는 데이터프레임과 결합 가능
df2 <- cbind(df1, c("dog", "cat", "bird", "dog"))
print(colnames(df2))
colnames(df2)[5] <- "pet"  # 새로 추가된 5번째 열에 "pet" 이라는 이름 지정
print(df2)
# cbind()와 rbind()를 이용해 벡터 또는 데이터프레임과 결합 가능
df2 <- cbind(df1, c("dog", "cat", "bird", "dog"))
print(colnames(df2))
colnames(df2)[5] <- "pet"  # 새로 추가된 5번째 열에 "pet" 이라는 이름 지정
print(df2)
df2 <- cbind(df1, c("dog", "cat", "bird", "dog"))
colnames(df2)[5] <- "pet"  # 새로 추가된 5번째 열에 "pet" 이라는 이름 지정.
# 지정하지 않을 시 열의 이름으로 벡터 자체가 들어감
print(df2)
iris
# dim() : 행과 열의 개수 출력
dim(iris)
# dim() : 행과 열의 개수 출력
print(dim(iris))
# nrow() : 행의 개수 출력
print(nrow(iris))
# ncol() : 열의 개수 출력
print(ncol(iris))
# colnames() : 열 이름 출력, names()와 결과 동일
print(colnames(iris))
# head() : 데이터셋의 앞부분 일부 출력
print(head(iris))
# tail() : 데이터셋의 뒷부분 일부 출력
print(tail(iris))
# rownames() : 열 이름 출력
print(rownames(iris))
# colnames() : 열 이름 출력, names()와 결과 동일
print(colnames(iris))
print(head(iris, n=10))
print(head(iris))        # head() : 데이터셋의 앞부분 일부 출력
print(head(iris, n=10))
str(iris)
print(iris[, 5])
unique(iris[, 5])
table(iris[, "Species"])
table(iris[, "Species"]) #
iris[, "Species"] #
print(iris[, 5])
print(table(iris[, "Species"]))
print(df1[, "religion"])
print(df1[, 1:3])
print(df1[, 1:2])
print(df1[, c(2, 4)])    # 여러개의 행 또는 열 추출 가능
## 2.3.3 행렬과 데이터프레임 다루기
print(iris)
# subset() 함수 이용하여 조건에 맞는 행과 열의 값 추출할 수 있음
# 매개변수 subset : 행에 대한 조건 지정
# 매개변수 select ; 추출하고자하는 열 지정
iris.new1 <- subset(iris, Species == "setosa")
# subset() 함수 이용하여 조건에 맞는 행과 열의 값 추출할 수 있음
# 매개변수 subset : 행에 대한 조건 지정
# 매개변수 select ; 추출하고자하는 열 지정
iris.new1 <- subset(iris, Species == "setosa")
print(iris.new1)
iris.new2 <- subset(iris, subset = sepal.Length > 5.0 & Sepal.Width > 4.0)
iris.new2 <- subset(iris, subset = Sepal.Length > 5.0 & Sepal.Width > 4.0)
print(iris.new2)
iris.new3 <- subset(iris, select = c("Sepal.Length", "Sepal.Width"))
print(iris.new3)
m1 <- matrix(1:20, nrow = 4, ncol = 5)                # 4x5 행렬
m2 <- matrix(21:40, nrow = 4, ncol = 5)               # 4x5 행렬
print(m1 + 2)
print(m2 * 3)
print(m1 + m2)
print(colSums(iris[, -5]))
print(t(m1))  # t() 함수를 사용해 전치행렬 출력 가능
m4
history()
install.packages(c("tibble", "readr"))
library(tools, lib.loc = "C:/Program Files/R/R-4.2.2/library")
install.packages(c("tibble", "readr"))
.libPaths()
install.packages(c("tibble", "readr"))
# 설치한 패키지를 import
library(tibble)
library(readr)
tibble()
nrow(subset(iris, Species == "setosa"))
# 파이프 연산자 적용
iris %>% subset(Speciess == "setosa")
# 파이프 연산자 적용
iris %>% subset(Species == "setosa")
# 파이프 연산자 적용
iris %>%
subset(Species == "setosa") %>%
nrow()
# 파이프 연산자 적용
iris %>%
subset(Species == "setosa") %>%
nrow()
inistall.packages("tidyverse")
install.packages("tidyverse")
# library() 함수를 이용해 설치한 패키지를 import
library(tidyverse)
# library() 함수를 이용해 설치한 패키지를 import
library(tidyverse)
install.packages("tidyverse")
# library() 함수를 이용해 설치한 패키지를 import
library(tidyverse)
# 파이프 연산자 적용
# x %>% f() %>% g() %>% h()
iris %>%
subset(Species == "setosa") %>%
nrow()
iris |>
subset(Species == "setosa") |>
nrow()
# place-holder '.'을 이용해 rhs에서 lhs가 사용될 위치를 지정
# 미지정 시 lhs는 rhs의 첫번째 인자로 사용됨
"World" %>% cat("Hello", .)
library(nycflights13)
install.packages("nycflights13")
library(nycflights13)
flights13
flights
flights
flights %>% View()
# tibble 생성
# tibble() 함수 사용
library(tibble)
mytb1 <- tibble(
x = 1.5,
y = 1,
z = x^2 + y
)
print(mytb)
print(mytb1)
mytb1 <- tibble(
x = 1:5,
y = 1,
z = x^2 + y
)
print(mytb1)
mytb1 <- tibble(
x = 1:5,
y = 1,             # 길이가 1인 입력은 자동으로 재사용함
z = x^2 + y,
`^___^` = TRUE
)
print(mytb1)
mytb1 <- tibble(
x = 1:5,
y = 1,             # 길이가 1인 입력은 자동으로 재사용함
z = x^2 + y,
`^ ___ ^` = TRUE     # ``(backticks)를 사용하여 변수명을 더 유연하게 지정할 수 있음
)
print(mytb1)
# tibble <-> dataframe 간 전환 가능
# as_tibble() : dataframe -> tibble 변환
# as.data.frame() : tibble -> dataframe 변환
as_tibble(iris)
as.data.frame(flights)
# tibble <-> dataframe 간 전환 가능
# as_tibble() : dataframe -> tibble 변환
# as.data.frame() : tibble -> dataframe 변환
as_tibble(iris)
as.data.frame(flights)
df
# tibble 객체는 부분집합을 만드는데 엄격함
# 하나의 열만 추출하려면 [[]] 또는 $ 사용
df <- data.frame(x=1:3, y=3:1)
df
# tibble 객체는 부분집합을 만드는데 엄격함
# 하나의 열만 추출하려면 [[]] 또는 $ 사용
df <- data.frame(x=1:3, y=3:1, z=4:6)
df
# object() 함수 : 객체의 타입을 알려주는 함수
df[, 1:2]
# object() 함수 : 객체의 타입을 알려주는 함수
df[, 1:2] %>% class()
df[, 1] %>% class()
df[, 1] %>% is()
df[, 1] %>% is.vector()
df[, 1] %>% is.data.frame()
tb1 <- tibble(x=1:3, y=3:1, z=4:6)
tb1
tb1
tb1[, 1:2] %>% class()     # data.frame
tb1[, 1:2] %>% class()
tb1[, 1] %>% class()       # inteager 형 벡터
tb1[, 1] %>% is()
tb1[, 1] %>% is.vector()
tb1[, 1] %>% is.data.frame()
tb1[[1]] %>% class()
tb1$x %>% class()
tb1[, 1:2] %>% class()
tb1[, 1] %>% class()
tb1[, 1] %>% is()
tb1[, 1] %>% is.vector()
## 4.6.2 read_csv() 함수
library(readr)
data <- read_csv("StudentSurvey.csv")
data <- read_csv("./dataSet/StudentSurvey.csv")
setwd("C:/R-2022")
data <- read_csv("./dataSet/StudentSurvey.csv")
data
sbp <- 125         # 수축기 혈압
dbp <- 93          # 이완기 혈압
if(sbp >= 160 | dbp >= 100) {
bp.type <- "2단계 고혈압"
} else if ((140 <= sbp & sbp <= 159) | (90 <= dbp & dbp <= 99)) {
bp.type <- "1단계 고혈압"
} else if ((120 <= sbp & sbp <= 139) | (80 <= dbp & dbp <= 89)) {
bp.type <- "고혈압 전단계"
} else if (sbp <= 120 & dbp < 80) {
bp.type <- "정상 혈압"
}
print(bp.type)
